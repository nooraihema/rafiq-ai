// context_tracker.js v2.0 - The Short-Term Memory Core (Enhanced)
// Purpose: maintain and analyze the immediate context of a conversation (working memory).
// Adds: weighted history, energy index, contextual summary, pattern detection, response satisfaction flags.

// =================================================================
// START: PATH UPDATES FOR NEW STRUCTURE
// =================================-===============================
import { DEBUG } from './config.js';
// =================================================================
// END: PATH UPDATES FOR NEW STRUCTURE
// =================================================================

const DEFAULT_MAX_HISTORY = 8;       // Default number of turns to keep (configurable)
const DECAY_BASE = 0.85;             // Exponential decay base for weighting older turns (0 < base < 1)
const LOOP_DETECTION_WINDOW = 3;     // Number of recent turns to use for loop detection
const SUMMARY_WINDOW = 5;            // How many recent turns to include in the generated summary

/**
 * Helper: safe getter for nested values
 */
function safeGet(obj, path, fallback = undefined) {
    try {
        return path.split('.').reduce((o, k) => (o && o[k] !== undefined) ? o[k] : fallback, obj);
    } catch (e) {
        return fallback;
    }
}

/**
 * Normalize a number into 0..1
 */
function clamp01(v) {
    if (Number.isFinite(v) === false) return 0;
    return Math.max(0, Math.min(1, v));
}

/**
 * Compute an exponential weight for index (0 newest, n oldest)
 */
function weightForIndex(index) {
    return Math.pow(DECAY_BASE, index);
}

/**
 * Produce a short textual summary from a list of emotive labels.
 * Example: ["anxiety","anxiety","decision_making"] -> "تكرر القلق ثم توجه لنقاش قرار"
 */
function generateSimpleSummaryFromConcepts(conceptsArray) {
    if (!conceptsArray || conceptsArray.length === 0) return '';
    const counts = {};
    conceptsArray.forEach(c => counts[c] = (counts[c] || 0) + 1);
    // sort by frequency
    const ordered = Object.entries(counts).sort((a,b) => b[1] - a[1]);
    const top = ordered.slice(0, 3).map(([k, v]) => `${k}${v>1 ? `(${v})` : ''}`).join('، ');
    return top;
}

/**
 * Class: ContextTracker
 * Maintains short-term conversational memory for a user and provides analysis utilities.
 */
export class ContextTracker {
    /**
     * Construct a new tracker.
     * @param {object} userProfile - The user's profile object (may include id, shortMemory, longMemory ref, prefs)
     * @param {object} opts - options: { maxHistory, decayBase }
     */
    constructor(userProfile = {}, opts = {}) {
        this.userId = safeGet(userProfile, 'id', 'anonymous');
        this.MAX_HISTORY = opts.maxHistory || userProfile.maxHistory || DEFAULT_MAX_HISTORY;
        // Allow overriding decay base per tracker
        if (opts.decayBase && typeof opts.decayBase === 'number') {
            // clamp sensible range
            this.decayBase = clamp01(opts.decayBase);
        } else {
            this.decayBase = DECAY_BASE;
        }
        // Internal history (array of turns). newest at end.
        // Each turn shape:
        // {
        //   timestamp,
        //   user_fingerprint,    // object produced by fingerprint engine
        //   ai_response,         // object produced by composition engine
        //   satisfaction: null|'positive'|'negative'|'neutral' (optional),
        //   meta: { energyIndex: 0.4, tokensCount: 12 } (optional)
        // }
        this.history = Array.isArray(userProfile.shortMemory) ? [...userProfile.shortMemory] : [];

        // Quick access cache of analyzed state (recomputed on analyzeState)
        this._lastAnalyzedState = null;
    }

    /**
     * Adds the latest turn (fingerprint and response) to the history.
     * Optionally include user feedback about satisfaction.
     * @param {object} fingerprint - The psychological fingerprint of the user's message.
     * @param {object} responsePayload - The response generated by the composition engine.
     * @param {object} opts - { satisfaction: 'positive'|'negative'|'neutral', extraMeta: {...} }
     */
    addTurn(fingerprint, responsePayload, opts = {}) {
        const entry = {
            timestamp: new Date().toISOString(),
            user_fingerprint: fingerprint || null,
            ai_response: responsePayload || null,
            satisfaction: opts.satisfaction || null,
            meta: opts.extraMeta || {}
        };

        this.history.push(entry);

        // Trim to MAX_HISTORY (oldest removed), keep newest at end
        if (this.history.length > this.MAX_HISTORY) {
            this.history.splice(0, this.history.length - this.MAX_HISTORY);
        }

        if (DEBUG) console.log(`[ContextTracker:${this.userId}] addTurn — history length:`, this.history.length);

        // invalidate cached analysis
        this._lastAnalyzedState = null;
    }

    /**
     * Manually mark user satisfaction for the last AI response.
     * Example: user clicks 👍/👎 in UI.
     * @param {'positive'|'negative'|'neutral'} satisfaction
     */
    markLastResponseSatisfaction(satisfaction) {
        if (!this.history.length) return false;
        const last = this.history[this.history.length - 1];
        last.satisfaction = satisfaction;
        this._lastAnalyzedState = null;
        return true;
    }

    /**
     * Compute an energy index for a given message string or fingerprint (heuristic).
     * Energy index estimates 'activation' (verbosity, punctuation, emphasis).
     * Returns 0..1
     */
    computeEnergyIndexFromFingerprint(fingerprint) {
        if (!fingerprint) return 0.0;

        // heuristics:
        // - token count relative to a reasonable scale (10..60)
        // - intensity contributes
        // - presence of punctuation(!?) increases energy
        const text = safeGet(fingerprint, 'originalMessage', '') || '';
        const tokensCount = text.trim().split(/\s+/).filter(Boolean).length;
        const tokenScore = clamp01((tokensCount - 3) / 40); // 0 at 3 tokens, ~1 at 43 tokens
        const intensity = clamp01(safeGet(fingerprint, 'primaryEmotion.intensity', 0.5));
        const punctuationBoost = /[!؟!?]{2,}/.test(text) ? 0.15 : 0;

        // Weighted sum
        const energy = clamp01(0.45 * tokenScore + 0.45 * intensity + punctuationBoost);
        return parseFloat(energy.toFixed(3));
    }

    /**
     * Detect simple patterns across the short history:
     * - repeated needs
     * - repeated concepts
     * - repeated responses/recipes
     * Returns an object with flags and counts.
     */
    detectPatterns() {
        const patterns = {
            repeatedNeeds: {},
            repeatedConcepts: {},
            repeatedRecipes: {},
            stuckNeedsSequence: false,
            stuckConceptsSequence: false
        };

        const needsSeq = this.history.map(h => safeGet(h, 'user_fingerprint.inferredNeed', null)).filter(Boolean);
        const conceptsSeq = this.history.map(h => safeGet(h, 'user_fingerprint.concepts', [])).map(arr => arr.join('|'));
        const recipesSeq = this.history.map(h => safeGet(h, 'ai_response.recipe', [])).map(r => r.join('|'));

        // counts
        needsSeq.forEach(n => patterns.repeatedNeeds[n] = (patterns.repeatedNeeds[n] || 0) + 1);
        conceptsSeq.forEach(c => patterns.repeatedConcepts[c] = (patterns.repeatedConcepts[c] || 0) + 1);
        recipesSeq.forEach(r => patterns.repeatedRecipes[r] = (patterns.repeatedRecipes[r] || 0) + 1);

        // check stuck sequences (last N same)
        if (needsSeq.length >= LOOP_DETECTION_WINDOW) {
            const last = needsSeq.slice(-LOOP_DETECTION_WINDOW);
            const allEqual = last.every(x => x === last[0]);
            patterns.stuckNeedsSequence = allEqual && last[0] !== null;
        }
        if (conceptsSeq.length >= LOOP_DETECTION_WINDOW) {
            const lastC = conceptsSeq.slice(-LOOP_DETECTION_WINDOW);
            const allEqualC = lastC.every(x => x === lastC[0]);
            patterns.stuckConceptsSequence = allEqualC && lastC[0] !== '';
        }

        return patterns;
    }

    /**
     * Analyze the recent history to extract meta-information.
     * Returns a detailed analysis object.
     */
    analyzeState() {
        // Cache results so repeated calls are cheap until next change
        if (this._lastAnalyzedState) return this._lastAnalyzedState;

        const state = {
            recent_concepts: new Map(),   // concept -> weighted score
            recent_needs: new Map(),      // need -> weighted score
            recent_recipes: new Map(),    // recipe string -> weighted score
            is_stuck_in_loop: false,
            emotional_trend: 'stable',    // 'improving', 'worsening', 'stable'
            weightedIntensity: 0.0,
            averageEnergyIndex: 0.0,
            summary: '',                  // textual summary of recent activity
            satisfactionTrend: 'unknown', // 'positive','negative','mixed','unknown'
            patterns: {},                 // raw pattern detections
            last_turn: this.history.length ? this.history[this.history.length - 1] : null
        };

        if (this.history.length === 0) {
            this._lastAnalyzedState = state;
            return state;
        }

        // We'll compute weighted aggregates: newest has index 0, next 1, etc.
        let weightedIntensitySum = 0;
        let weightSum = 0;
        let energySum = 0;
        let satisfactionCounts = { positive: 0, negative: 0, neutral: 0, unknown: 0 };

        for (let i = 0; i < this.history.length; i++) {
            const idxFromEnd = this.history.length - 1 - i; // 0 = newest
            const turn = this.history[idxFromEnd];
            const w = Math.pow(this.decayBase, i); // newer => i small => higher weight

            // intensity
            const intensity = clamp01(safeGet(turn, 'user_fingerprint.primaryEmotion.intensity', 0.5));
            weightedIntensitySum += intensity * w;
            weightSum += w;

            // energy
            const energy = this.computeEnergyIndexFromFingerprint(turn.user_fingerprint);
            energySum += energy * w;

            // concepts
            const concepts = Array.isArray(safeGet(turn, 'user_fingerprint.concepts', [])) ? turn.user_fingerprint.concepts : [];
            concepts.forEach(c => {
                state.recent_concepts.set(c, (state.recent_concepts.get(c) || 0) + w);
            });

            // needs
            const need = safeGet(turn, 'user_fingerprint.inferredNeed', null);
            if (need) state.recent_needs.set(need, (state.recent_needs.get(need) || 0) + w);

            // recipes
            const recipe = safeGet(turn, 'ai_response.recipe', []) || [];
            const recipeKey = Array.isArray(recipe) ? recipe.join('|') : String(recipe);
            if (recipeKey) state.recent_recipes.set(recipeKey, (state.recent_recipes.get(recipeKey) || 0) + w);

            // satisfaction counts
            const s = turn.satisfaction || 'unknown';
            if (!satisfactionCounts[s]) satisfactionCounts[s] = 0;
            satisfactionCounts[s] += 1 * w;
        }

        // finalize weighted intensity & energy
        state.weightedIntensity = weightSum > 0 ? parseFloat((weightedIntensitySum / weightSum).toFixed(3)) : 0.0;
        state.averageEnergyIndex = weightSum > 0 ? parseFloat((energySum / weightSum).toFixed(3)) : 0.0;

        // emotional trend: compare oldest vs newest (using weighted average approach)
        const oldest = this.history[0];
        const newest = this.history[this.history.length - 1];
        const oldestIntensity = clamp01(safeGet(oldest, 'user_fingerprint.primaryEmotion.intensity', state.weightedIntensity));
        const newestIntensity = clamp01(safeGet(newest, 'user_fingerprint.primaryEmotion.intensity', state.weightedIntensity));
        if (newestIntensity <= oldestIntensity - 0.2) state.emotional_trend = 'improving';
        else if (newestIntensity >= oldestIntensity + 0.2) state.emotional_trend = 'worsening';
        else state.emotional_trend = 'stable';

        // satisfaction trend
        const pos = satisfactionCounts.positive || 0;
        const neg = satisfactionCounts.negative || 0;
        if (pos > neg * 1.2 && pos > 0) state.satisfactionTrend = 'positive';
        else if (neg > pos * 1.2 && neg > 0) state.satisfactionTrend = 'negative';
        else state.satisfactionTrend = (pos===0 && neg===0) ? 'unknown' : 'mixed';

        // convert recent_concepts map to sorted array for summary
        const conceptsSorted = [...state.recent_concepts.entries()].sort((a,b) => b[1]-a[1]).map(e => e[0]);
        const needsSorted = [...state.recent_needs.entries()].sort((a,b) => b[1]-a[1]).map(e => e[0]);

        // generate short textual summary
        const summaryParts = [];
        if (needsSorted.length) summaryParts.push(`الاحتياجات: ${needsSorted.slice(0,3).join('، ')}`);
        if (conceptsSorted.length) summaryParts.push(`الموضوعات: ${conceptsSorted.slice(0,5).join('، ')}`);
        summaryParts.push(`اتجاه المشاعر: ${state.emotional_trend}`);
        summaryParts.push(`مؤشر الطاقة: ${state.averageEnergyIndex}`);
        state.summary = summaryParts.join(' | ');

        // patterns
        const patterns = this.detectPatterns();
        state.patterns = patterns;
        state.is_stuck_in_loop = patterns.stuckNeedsSequence || patterns.stuckConceptsSequence;

        // last turn quick info
        state.last_turn_info = {
            timestamp: safeGet(newest, 'timestamp', null),
            last_intensity: clamp01(safeGet(newest, 'user_fingerprint.primaryEmotion.intensity', 0)),
            last_concepts: safeGet(newest, 'user_fingerprint.concepts', []),
            last_need: safeGet(newest, 'user_fingerprint.inferredNeed', null),
            last_recipe: safeGet(newest, 'ai_response.recipe', []),
            last_satisfaction: newest.satisfaction || null
        };

        // store analysis
        this._lastAnalyzedState = state;

        if (DEBUG) console.log(`[ContextTracker:${this.userId}] analyzeState =>`, {
            weightedIntensity: state.weightedIntensity,
            avgEnergy: state.averageEnergyIndex,
            emotionalTrend: state.emotional_trend,
            summary: state.summary,
            is_stuck_in_loop: state.is_stuck_in_loop
        });

        return state;
    }

    /**
     * Create a contextual summary suitable to send to higher-level memory or the composition engine.
     * Returns an object with shortSummary and structured metadata.
     */
    generateContextualSummary() {
        const analysis = this.analyzeState();

        return {
            shortSummary: analysis.summary,
            dominantNeeds: [...analysis.recent_needs.entries()].sort((a,b) => b[1]-a[1]).slice(0,3).map(e => e[0]),
            dominantConcepts: [...analysis.recent_concepts.entries()].sort((a,b) => b[1]-a[1]).slice(0,5).map(e => e[0]),
            emotionalTrend: analysis.emotional_trend,
            energyIndex: analysis.averageEnergyIndex,
            isStuck: analysis.is_stuck_in_loop,
            patterns: analysis.patterns
        };
    }

    /**
     * Serialize the short-term history to be saved into user profile or DB.
     * This reduces bulky fields if necessary.
     */
    serialize() {
        // optionally strip heavy fields from the fingerprints (if they contain big objects)
        // but for now we return full history (caller may choose to persist).
        return JSON.parse(JSON.stringify(this.history));
    }

    /**
     * Restore tracker state from a serialized history array (overwrites current history).
     * Useful when loading user profile from DB.
     */
    restoreFromSerialized(serializedHistory = []) {
        if (!Array.isArray(serializedHistory)) return false;
        this.history = [...serializedHistory].slice(-this.MAX_HISTORY);
        this._lastAnalyzedState = null;
        return true;
    }
}
